@page "/"
@namespace ToDoList
@using Raven.Client.Documents
@using Raven.Client.Documents.Linq
@inject IJSRuntime JSRuntime

<h1>Lista - @Tasks.Count elementów</h1>
<select @onchange="fliterList">
    <option value="notDone">Niewykonane</option>
    <option value="all">Wszystkie</option>
</select>
    @if (Tasks == null)
    {
        <p>Lista jest pusta</p>
    }
    else
    {
        <ul>
            @foreach (var item in Tasks.OrderBy(t => t.WhenAdded))
            {
                <div>
                    <ToDoList.Client.Components.TaskItem Item="@item" OnChamge="@SaveTask"  OnDelete="@DeleteTask"/>
                </div>
            }
        </ul>
    }
    <hr/>
    <h2>Dodawanie zadań do listy</h2>
    <br/>
    <label for="addTask">Napisz nowe zadanie</label>
    <input @bind="InputValue" name="addTask" type="text" />
    <Button Color="ButtonColor.Primary" @onclick="AddItem">Dodaj</Button>
    <hr/>
    <div class="task-table">
        <table>
            <tr>
                <th>ID</th>
                <th>Zadanie</th>
                <th>Czy zrobione?</th>
                <th>Czy Wyłączony?</th>
            </tr>
            @foreach (var item in Tasks.OrderBy(o => o.WhenAdded))
            {
                <tr>
                    <td>@item.WhenAdded</td>
                    <td>@item.WhatToDo</td>
                    <td class="@(item.isDone ? "true" : "false")">@item.isDone</td>
                </tr>
            }
        </table>
    </div>
    @code {
        private string InputValue { get; set; }
        private string editStyles = "visibility: hidden;";
        public List<Data.Task> Tasks { get; set; }
        private DocumentStore store;
        private string selectedFilter = "notDone";

        private void fliterList(ChangeEventArgs e)
        {
            selectedFilter = e.Value?.ToString();
            Refresh();
        }

        private void Refresh()
        {
            using var session = store.OpenSession();
            var query = session.Query<Data.Task>();
            if (selectedFilter == "notDone")
                query = query.Where(w => w.isDone == false);
            Tasks = query.ToList();
        }

        private void SaveTask(Data.Task item)
        {       
            using var session = store.OpenSession();
            Data.Task loadedTask = session.Load<Data.Task>(item.Id);
            loadedTask.WhatToDo = item.WhatToDo;
            loadedTask.isDone = item.isDone;
            session.SaveChanges();
            Refresh();
        }
        private void DeleteTask(Data.Task item)
        {
            using var session = store.OpenSession();
            Data.Task loadedTask = session.Load<Data.Task>(item.Id);
            session.Delete(loadedTask);
            session.SaveChanges();
            Refresh();
        }

        private async Task AddItem()
        {
            if (string.IsNullOrEmpty(InputValue))
            {
                await JSRuntime.InvokeVoidAsync("alert", "Błąd! Pole tekstowe nie może być puste!");
            }
            else
            {
                using var session = store.OpenSession();
                session.Store(new Data.Task { WhatToDo = InputValue, isDone = false, WhenAdded = DateTime.Now});
                session.SaveChanges();  
                Tasks = session.Query<Data.Task>().ToList();
                InputValue = "";
            }
        }
        protected override async Task OnInitializedAsync()
        {
            store = new DocumentStore
            {
                Urls = new string[] { "http://localhost:8080" },
                Database = "Tasks",
            };
            store.Initialize();
            Refresh();
        }
    }
